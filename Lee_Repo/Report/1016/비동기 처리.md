# 비동기 처리와 Promise, async/await

https://youtu.be/6AhQFPVl96s?si=wI6Vvkp-yrUGdkyk

## 1. 비동기 처리의 개념

프로그래밍에서 비동기 처리(asynchronous processing)란, 어떤 작업이 끝날 때까지 프로그램의 실행이 멈추지 않고 다음 작업을 계속 진행할 수 있도록 하는 방식을 말한다.  
일반적인 **동기(synchronous)** 방식에서는 한 작업이 완료되어야 다음 코드가 실행되므로, 시간이 오래 걸리는 작업(예: 서버 요청, 파일 읽기 등)이 있으면 전체 프로그램이 멈춘 것처럼 보일 수 있다.  
반면 비동기 방식은 이러한 작업을 백그라운드에서 처리하고, 결과가 준비되면 그때 콜백을 통해 알려주는 식으로 동작한다.  
이 덕분에 사용자 인터페이스가 멈추지 않고 자연스러운 프로그램 흐름을 유지할 수 있다.

---

## 2. 콜백 함수의 한계

자바스크립트에서는 초기부터 비동기 처리를 위해 **콜백(callback)** 방식을 사용했다.  
예를 들어, 데이터를 서버에서 불러온 뒤 그 결과를 처리하는 코드를 콜백 함수로 전달하는 식이다.  
하지만 콜백 안에서 또 다른 콜백을 호출해야 하는 경우가 많아지면서 코드가 중첩되고 복잡해지는 문제가 생겼다.  
이 문제를 흔히 “콜백 지옥(callback hell)”이라고 부른다.  
이 문제를 해결하기 위해 등장한 것이 **Promise**이다.

---

## 3. React에서 비동기 처리: Promise vs async/await

비동기 처리는 React 애플리케이션에서 서버 데이터 요청, 파일 읽기, API 호출 등 다양한 상황에서 필수적으로 사용된다.  
이번 예시에서는 **Promise**와 **async/await** 두 가지 방법으로 동일한 기능을 구현하여 비교해본다.

### 1. Promise를 이용한 예시

아래는 `Promise`를 이용해 API에서 사용자 데이터를 불러오는 React 컴포넌트이다.  
`.then()`과 `.catch()` 체이닝을 통해 비동기 처리를 수행한다.

```jsx
import React, { useEffect, useState } from "react";

function UserListPromise() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Promise를 사용한 비동기 처리
    fetch("https://jsonplaceholder.typicode.com/users")
      .then((response) => response.json())
      .then((data) => {
        setUsers(data);
        setLoading(false);
      })
      .catch((error) => {
        console.error("데이터 불러오기 실패:", error);
        setLoading(false);
      });
  }, []);

  if (loading) return <p>로딩 중...</p>;

  return (
    <div>
      <h2>사용자 목록 (Promise 예시)</h2>
      <ul>
        {users.map((user) => (
          <li key={user.id}>
            {user.name} ({user.email})
          </li>
        ))}
      </ul>
    </div>
  );
}

export default UserListPromise;
```

### 2.async/await를 이용한 예시

같은 기능을 async/await 문법으로 작성하면,
비동기 코드를 마치 동기 코드처럼 읽기 쉽게 만들 수 있다.

```jsx
import React, { useEffect, useState } from "react";

function UserListAsync() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // async 함수를 useEffect 내부에서 정의
    const fetchUsers = async () => {
      try {
        const response = await fetch(
          "https://jsonplaceholder.typicode.com/users"
        );
        const data = await response.json();
        setUsers(data);
      } catch (error) {
        console.error("데이터 불러오기 실패:", error);
      } finally {
        setLoading(false);
      }
    };

    fetchUsers();
  }, []);

  if (loading) return <p>로딩 중...</p>;

  return (
    <div>
      <h2>사용자 목록 (async/await 예시)</h2>
      <ul>
        {users.map((user) => (
          <li key={user.id}>
            {user.name} ({user.email})
          </li>
        ))}
      </ul>
    </div>
  );
}

export default UserListAsync;
```

## 결론

Promise는 비동기 처리의 기본적인 형태로, 간단한 요청에 적합하다.
async/await는 코드의 가독성과 유지보수성을 높여, 실무에서 더 자주 사용된다.
실제 프로젝트에서는 Promise와 async/await를 적절히 혼용하여 상황에 맞게 사용하는 것이 효율적이다.
예를 들어, Promise.all()과 async/await를 함께 사용하면
여러 비동기 요청을 동시에 처리하면서도 깔끔한 코드 구성이 가능하다.
